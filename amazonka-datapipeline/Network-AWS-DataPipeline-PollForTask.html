<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.AWS.DataPipeline.PollForTask</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Network-AWS-DataPipeline-PollForTask.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">amazonka-datapipeline-0.3.4: Amazon Data Pipeline SDK.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.AWS.DataPipeline.PollForTask</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Request</a><ul><li><a href="#g:2">Request constructor</a></li><li><a href="#g:3">Request lenses</a></li></ul></li><li><a href="#g:4">Response</a><ul><li><a href="#g:5">Response constructor</a></li><li><a href="#g:6">Response lenses</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Task runners call <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> to receive a task to perform from AWS Data
 Pipeline. The task runner specifies which tasks it can perform by setting a
 value for the <code>workerGroup</code> parameter. The task returned can come from any of
 the pipelines that match the <code>workerGroup</code> value passed in by the task runner
 and that was launched using the IAM user credentials specified by the task
 runner.</p><p>If tasks are ready in the work queue, <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> returns a response
 immediately. If no tasks are available in the queue, <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> uses
 long-polling and holds on to a poll connection for up to a 90 seconds, during
 which time the first newly scheduled task is handed to the task runner. To
 accomodate this, set the socket timeout in your task runner to 90 seconds.
 The task runner should not call <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> again on the same <code>workerGroup</code>
 until it receives a response, and this can take up to 90 seconds.</p><p><a href="http://docs.aws.amazon.com/datapipeline/latest/APIReference/API_PollForTask.html">http://docs.aws.amazon.com/datapipeline/latest/APIReference/API_PollForTask.html</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:PollForTask">PollForTask</a></li><li class="src short"><a href="#v:pollForTask">pollForTask</a> :: Text -&gt; <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></li><li class="src short"><a href="#v:pftHostname">pftHostname</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</li><li class="src short"><a href="#v:pftInstanceIdentity">pftInstanceIdentity</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a>)</li><li class="src short"><a href="#v:pftWorkerGroup">pftWorkerGroup</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> Text</li><li class="src short"><span class="keyword">data</span> <a href="#t:PollForTaskResponse">PollForTaskResponse</a></li><li class="src short"><a href="#v:pollForTaskResponse">pollForTaskResponse</a> :: <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></li><li class="src short"><a href="#v:pftrTaskObject">pftrTaskObject</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a>)</li></ul></div><div id="interface"><h1 id="g:1">Request</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PollForTask" class="def">PollForTask</a></p><div class="subs instances"><p id="control.i:PollForTask" class="caption collapser" onclick="toggleSection('i:PollForTask')">Instances</p><div id="section.i:PollForTask" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Text-Read.html#t:Read">Read</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">AWSRequest <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToQuery <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToPath <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToHeaders <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToJSON <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Sv <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> = <a href="Network-AWS-DataPipeline-Types.html#t:DataPipeline">DataPipeline</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rs <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> = <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:2">Request constructor</h2><div class="top"><p class="src"><a name="v:pollForTask" class="def">pollForTask</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Text</td><td class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftWorkerGroup">pftWorkerGroup</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftHostname">pftHostname</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code>Text</code></li><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftInstanceIdentity">pftInstanceIdentity</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a></code></li><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftWorkerGroup">pftWorkerGroup</a></code> <code>::</code> <code>Text</code></li></ul></div></div><h2 id="g:3">Request lenses</h2><div class="top"><p class="src"><a name="v:pftHostname" class="def">pftHostname</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> Text)</p><div class="doc"><p>The public DNS name of the calling task runner.</p></div></div><div class="top"><p class="src"><a name="v:pftInstanceIdentity" class="def">pftInstanceIdentity</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:InstanceIdentity">InstanceIdentity</a>)</p><div class="doc"><p>Identity information for the EC2 instance that is hosting the task runner.
 You can get this value from the instance using 'http://169.254.169.254/latest/meta-data/instance-id'. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html">Instance Metadata</a> in the <em>Amazon Elastic ComputeCloud User Guide.</em> Passing in this value proves that your task runner is
 running on an EC2 instance, and ensures the proper AWS Data Pipeline service
 charges are applied to your pipeline.</p></div></div><div class="top"><p class="src"><a name="v:pftWorkerGroup" class="def">pftWorkerGroup</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a> Text</p><div class="doc"><p>The type of task the task runner is configured to accept and process. The
 worker group is set as a field on objects in the pipeline when they are
 created. You can only specify a single value for <code>workerGroup</code> in the call to <code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTask">PollForTask</a></code>. There are no wildcard values permitted in <code>workerGroup</code>; the string must be
 an exact, case-sensitive, match.</p></div></div><h1 id="g:4">Response</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PollForTaskResponse" class="def">PollForTaskResponse</a></p><div class="subs instances"><p id="control.i:PollForTaskResponse" class="caption collapser" onclick="toggleSection('i:PollForTaskResponse')">Instances</p><div id="section.i:PollForTaskResponse" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Text-Read.html#t:Read">Read</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FromJSON <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:5">Response constructor</h2><div class="top"><p class="src"><a name="v:pollForTaskResponse" class="def">pollForTaskResponse</a> :: <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></p><div class="doc"><p><code><a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a></code> constructor.</p><p>The fields accessible through corresponding lenses are:</p><ul><li><code><a href="Network-AWS-DataPipeline-PollForTask.html#v:pftrTaskObject">pftrTaskObject</a></code> <code>::</code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a></code></li></ul></div></div><h2 id="g:6">Response lenses</h2><div class="top"><p class="src"><a name="v:pftrTaskObject" class="def">pftrTaskObject</a> :: Lens' <a href="Network-AWS-DataPipeline-PollForTask.html#t:PollForTaskResponse">PollForTaskResponse</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.8.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Network-AWS-DataPipeline-Types.html#t:TaskObject">TaskObject</a>)</p><div class="doc"><p>The information needed to complete the task that is being assigned to the
 task runner. One of the fields returned in this object is <code>taskId</code>, which
 contains an identifier for the task being assigned. The calling task runner
 uses <code>taskId</code> in subsequent calls to <code>ReportTaskProgress</code> and <code>SetTaskStatus</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.0</p></div></body></html>